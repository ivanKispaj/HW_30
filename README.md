# HW_30

### Задача
    В 28 модуле для левой части разбитого массива мы запускали рекурсию в потоке. Теперь нужно сделать так,
    чтобы левая часть алгоритма пробрасывалась в тот же пул потоков,
    в котором в данный момент выполняется задание на сортировку отдельной части массива.

    Возникает проблема, которую придется решить:
    мы не можем больше ожидать завершения выполнения сортировки левой части массива.
    Ниже приведен код из модуля 28: 


```C++

       if(make_thread && (right_bound - left > 10000))
   {
       // если элементов в левой части больше чем 10000
       // вызываем асинхронно рекурсию для правой части
       auto f = async(launch::async, [&]() {
           quicksort(array,left,right_bound);
       });
       quicksort(array, left_bound, right);
   } else {
       // запускаем обе части синхронно
       quicksort(array, left, right_bound);
       quicksort(array, left_bound, right);
   }
   ```

```C++
   if(make_thread && (right_bound - left > 10000))
   {
       auto f = pool.push_task(quicksort,array,left,right_bound);
       quicksort(array, left_bound, right);
       f.wait(); // нельзя так написать
   } else {
       // запускаем обе части синхронно
       quicksort(array, left, right_bound);
       quicksort(array, left_bound, right);
   }
```

>Нужно придумать механизм, который переводил бы родительскую задачу в состояние готовности (фьючерс) тогда,
> когда все ее подзадачи были совершены.
>Задачу можно решить, используя std::promise и std::shared_ptr,
> где последний поможет в качестве счетчика ссылок на родительскую задачу.
> За основу возьмите пул потоков из третьего юнита с концепцией work stealing.
>Продемонстрируйте скорость работы алгоритма быстрой сортировки при использовании пула потоков.
> Учитывайте, что не стоит запускать задачу на вычисление левой части алгоритма в качестве подзадачи,
> если >количество элементов в этой части не превосходит 100000 (расходы на захват мьютекса очень велики).
